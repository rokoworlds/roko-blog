---
title: '#конспекты: Работа Event loop'
description: 'конспеты, заметки и заключения по работе event loop в контексте браузера'
pubDate: 2025-04-28

---

# #конспекты: Работа цикла событий в контексте браузера

Рассмотрим работу цикла событий в контексте браузера.

Цикл событий начинает свою работу, когда открывается веб-страница, и браузер начинает обработку JavaScript-файла, который мы передали. Он продолжает свою работу, пока веб-страница открыта, независимо от наличия событий, с которыми нужно работать. Он постоянно находится в активном состоянии, готовый обрабатывать события и выполнять асинхронные задачи.

Давайте разберемся в деталях.

Все функции, операции и задачи из нашего кода последовательно помещаются в стек вызовов (Call Stack). Задачи в стеке вызовов выполняются по принципу FILO (first-in-last-out), то есть последняя добавленная задача выполняется первой.

Если наш код является синхронным, все задачи выполняются последовательно. Например:

```js
console.log(1);
console.log(2);
console.log(3);
```

В консоли будут выведены числа 1, 2, 3 по порядку.

Однако при работе с асинхронным кодом ситуация меняется. Когда встречается асинхронная задача, такая как setTimeout, она не помещается в стек вызовов.

Давайте рассмотрим пример:

```js
console.log(1);


setTimeout(() => {

    console.log(2);

}, 1000);


console.log(3);
```

Шаги выполнения:

1. Функция console.log(1) помещается в стек вызовов и выполняется сразу же. Она выводит число 1 и удаляется из стека.
2. Функция setTimeout добавляется в стек вызовов. Она представляет собой функцию Web API, предоставляемую браузером. Браузер берет на себя обработку этой задачи, так как она асинхронная. Функция setTimeout удаляется из стека.
3. Функция console.log(3) добавляется в стек вызовов и выполняется. Она выводит число 3 и удаляется из стека.
4. По прошествии указанного времени (в данном случае 1000 миллисекунд), задача из setTimeout помещается в очередь задач (Task Queue).
5. Цикл событий проверяет, является ли стек вызовов пустым. Если стек вызовов пуст и все задачи в нем выполнены, он берет первую задачу из очереди задач и помещает ее в стек вызовов.
6. Задача console.log(2) выполняется, выводит число 2 в консоль и удаляется из стека вызовов.

В результате в консоли мы увидим числа 1, 3, 2.

Таким образом, цикл событий отвечает за обработку асинхронных задач и управляет их выполнением. Стек вызовов используется для синхронного выполнения кода, а очередь задач (Task Queue) служит для хранения и выполнения асинхронных задач, когда стек вызовов пуст.

Важно помнить, что Web API предоставляет различные функции и возможности, такие как таймеры (setTimeout, setInterval), работа с сетью (fetch, AJAX), и другие, которые помогают выполнять асинхронные операции. Цикл событий сотрудничает с Web API и Task Queue, чтобы обеспечить эффективное выполнение асинхронного кода.

Видишь, не так все сложно. Ты отлично справляешься и схватываешь на лету.

В дополнение к Циклу Событий, Очереди Задач и Event Loop, существует еще одна важная составляющая — Очередь Микрозадач (Microtask Queue) или Очередь Микротасков.

Очередь Микрозадач предназначена для выполнения микрозадач, таких как промисы (Promise), функции async/await, функция queueMicrotask() и mutationObserver. Они имеют более высокий приоритет выполнения и выполняются в специальной очереди.

При размещении задач в Очереди Микрозадач, они не добавляются по одной, как в Очереди Задач. Вместо этого, все микрозадачи в очереди выполняются последовательно до ее опустошения. Если в процессе выполнения микрозадачи добавляются еще задачи в очередь, они тоже будут выполнены до тех пор, пока очередь не станет пустой.

Таким образом, Очередь Микрозадач обеспечивает выполнение задач с более высоким приоритетом и гарантирует их последовательное выполнение, что полезно при работе с промисами и асинхронными функциями.

```js
console.log(1);

setTimeout(() => {

    console.log(2);

}, 1000);

console.log(3);

Promise.resolve().then(() => {

    console.log(4);

});

```

Шаги выполнения:

1. Функция console.log(1) помещается в стек вызовов и выполняется сразу же. Она выводит число 1 и удаляется из стека.
2. Функция setTimeout добавляется в стек вызовов. Она представляет собой функцию Web API, предоставляемую браузером. Браузер берет на себя обработку этой задачи, так как она асинхронная. Функция setTimeout удаляется из стека.
3. Функция console.log(3) добавляется в стек вызовов и выполняется. Она выводит число 3 и удаляется из стека.
4. Promise.resolve().then(() => { console.log(4); }) — это микрозадача, поэтому она добавляется в очередь микрозадач.
5. По прошествии указанного времени (в данном случае 1000 миллисекунд), задача из setTimeout помещается в очередь задач (Task Queue).
6. Цикл событий проверяет, является ли стек вызовов пустым. Если стек вызовов пуст и все задачи в нем выполнены, он берет первую задачу из очереди микрозадач и помещает ее в стек вызовов.
7. Микрозадача console.log(4) выполняется, выводит число 4 в консоль и удаляется из стека вызовов.
8. Цикл событий проверяет очередь задач (Task Queue). Задача из setTimeout доступна для выполнения.
9. Задача console.log(2) выполняется, выводит число 2 в консоль и удаляется из стека вызовов.

В результате в консоли мы увидим числа 1, 3, 4, 2.

И так, мы разобрали что такое асинхронность в JavaScript и какими механизмами она управляется. 